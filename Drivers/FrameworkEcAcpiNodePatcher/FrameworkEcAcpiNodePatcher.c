#include <Library/BaseMemoryLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiLib.h>

#include <Protocol/AcpiSystemDescriptionTable.h>

#include <Guid/Acpi.h>
#include <Guid/FileInfo.h>

EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER* gRsdp = NULL;
EFI_ACPI_SDT_HEADER* gXsdt = NULL;
UINT64 gXsdtEnd = 0;

EFI_EVENT mExitBootServicesEvent = NULL;

/* FRMWC004 */
unsigned char FrmwC004AMLBuffer[] = {
	0x53, 0x53, 0x44, 0x54, 0x69, 0x00, 0x00, 0x00, 0x02, 0xdf, 0x46, 0x57, 0x4b, 0x00, 0x00, 0x00, 0x46, 0x52,
	0x4d, 0x57, 0x43, 0x30, 0x30, 0x34, 0x03, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x54, 0x4c, 0x30, 0x09, 0x21, 0x20,
	0x10, 0x44, 0x04, 0x5f, 0x53, 0x42, 0x5f, 0x5b, 0x82, 0x3c, 0x43, 0x52, 0x45, 0x43, 0x08, 0x5f, 0x48, 0x49,
	0x44, 0x0d, 0x46, 0x52, 0x4d, 0x57, 0x43, 0x30, 0x30, 0x34, 0x00, 0x08, 0x5f, 0x55, 0x49, 0x44, 0x01, 0x08,
	0x5f, 0x44, 0x44, 0x4e, 0x0d, 0x45, 0x43, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x44, 0x65,
	0x76, 0x69, 0x63, 0x65, 0x00, 0x14, 0x09, 0x5f, 0x53, 0x54, 0x41, 0x00, 0xa4, 0x0a, 0x0f};
unsigned int FrmwC004AMLLen = 105;

/* GOOG0004 */
unsigned char Goog0004AMLBuffer[] = {
	0x53, 0x53, 0x44, 0x54, 0x69, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x47, 0x4f, 0x4f, 0x47, 0x00, 0x00, 0x47, 0x4f,
	0x4f, 0x47, 0x30, 0x30, 0x30, 0x34, 0x03, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x54, 0x4c, 0x04, 0x04, 0x25, 0x20,
	0x10, 0x44, 0x04, 0x5f, 0x53, 0x42, 0x5f, 0x5b, 0x82, 0x3c, 0x43, 0x52, 0x45, 0x43, 0x08, 0x5f, 0x48, 0x49,
	0x44, 0x0d, 0x47, 0x4f, 0x4f, 0x47, 0x30, 0x30, 0x30, 0x34, 0x00, 0x08, 0x5f, 0x55, 0x49, 0x44, 0x01, 0x08,
	0x5f, 0x44, 0x44, 0x4e, 0x0d, 0x45, 0x43, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x44, 0x65,
	0x76, 0x69, 0x63, 0x65, 0x00, 0x14, 0x09, 0x5f, 0x53, 0x54, 0x41, 0x00, 0xa4, 0x0a, 0x0f};
unsigned int Goog0004AMLLen = 105;

EFI_STATUS
PatchAcpi(VOID) {
	EFI_STATUS Status = EFI_SUCCESS;
	VOID* Buffer;

	CONST VOID* SourceAMLBuffer = _gPcd_FixedAtBuild_PcdUseFrameworkECAcpiNode ? FrmwC004AMLBuffer : Goog0004AMLBuffer;
	CONST UINTN SourceAMLLen    = _gPcd_FixedAtBuild_PcdUseFrameworkECAcpiNode ? FrmwC004AMLLen    : Goog0004AMLLen;

	EfiGetSystemConfigurationTable(&gEfiAcpi20TableGuid, (VOID**)&gRsdp);
	if(!gRsdp) {
		return EFI_DEVICE_ERROR;
	}

	gXsdt = (EFI_ACPI_SDT_HEADER*)(gRsdp->XsdtAddress);
	gXsdtEnd = gRsdp->XsdtAddress + gXsdt->Length;

	Status = gBS->AllocatePool(EfiRuntimeServicesData, SourceAMLLen, (VOID**)&Buffer);
	if(Status != EFI_SUCCESS) {
		goto Out;
	}

	CopyMem(Buffer, SourceAMLBuffer, SourceAMLLen);
	((UINT64*)gXsdtEnd)[0] = (UINT64)Buffer;
	gXsdt->Length += sizeof(UINT64);
	gXsdtEnd = gRsdp->XsdtAddress + gXsdt->Length;

	gXsdt->Checksum = 0;
	gXsdt->Checksum = CalculateCheckSum8((UINT8*)gXsdt, gXsdt->Length);

Out:
	return Status;
}

VOID EFIAPI NotifyExitBootServices(IN EFI_EVENT Event, IN VOID* Context) {
	PatchAcpi();
Out:
	gBS->CloseEvent(mExitBootServicesEvent);
}

EFI_STATUS
EFIAPI
AcpiPatcherEntryPoint(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE* SystemTable) {
	EFI_STATUS Status = EFI_SUCCESS;
	gBS->CreateEvent(EVT_SIGNAL_EXIT_BOOT_SERVICES, TPL_NOTIFY, NotifyExitBootServices, NULL,
	                 &mExitBootServicesEvent);
Out:
	return Status;
}
